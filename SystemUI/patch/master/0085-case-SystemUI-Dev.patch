From aa9b560a560590fcab9bc794075d9f6afec88874 Mon Sep 17 00:00:00 2001
From: LRH <lironghui@qucci.com>
Date: Wed, 1 Mar 2017 20:17:39 +0800
Subject: [PATCH 085/185] =?UTF-8?q?=E3=80=90case=E3=80=91=E6=B7=BB?=
 =?UTF-8?q?=E5=8A=A0=E5=85=B6=E4=BB=96=E4=BA=BA=E4=BF=AE=E6=94=B9SystemUI?=
 =?UTF-8?q?=E9=83=A8=E5=88=86=E4=BB=A3=E7=A0=81=EF=BC=8C=E5=90=8C=E6=AD=A5?=
 =?UTF-8?q?=E5=88=B0Dev?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 SystemUI/mytarfile.tar                             | Bin 0 -> 10240 bytes
 .../src/com/android/systemui/BatteryMeterView.java |   2 +
 .../com/android/systemui/SmartGestureService.java  | 125 ++++++++++++++---
 .../applock/ConfirmAppLockPasswordActivity.java    | 151 ++++-----------------
 .../systemui/keyguard/KeyguardViewMediator.java    |   4 +
 .../systemui/screenshot/GlobalScreenshot.java      |   5 +-
 .../statusbar/KeyguardIndicationController.java    |   4 +-
 .../systemui/statusbar/phone/PhoneStatusBar.java   |  12 +-
 .../phone/StatusBarKeyguardViewManager.java        |  29 +++-
 .../statusbar/policy/MobileSignalController.java   |   6 +-
 .../statusbar/policy/NetworkControllerImpl.java    |  21 +++
 .../com/android/systemui/volume/VolumeDialog.java  |   6 +
 .../systemui/volume/VolumeDialogController.java    |   5 +
 13 files changed, 216 insertions(+), 154 deletions(-)
 create mode 100644 SystemUI/mytarfile.tar

diff --git a/SystemUI/mytarfile.tar b/SystemUI/mytarfile.tar
new file mode 100644
index 0000000000000000000000000000000000000000..9df64990f7be3c1f7194a0c22852a1ab3a09f3c5
GIT binary patch
literal 10240
zcmeIu0Sy2E0K%a6Pi+o2h(KY$fB^#r3>YwAz<>b*1`HT5V8DO@0|pEjFkrxd0RsjM
P7%*VKfB^#r47?2tC;$Kf

literal 0
HcmV?d00001

diff --git a/SystemUI/src/com/android/systemui/BatteryMeterView.java b/SystemUI/src/com/android/systemui/BatteryMeterView.java
index 265604a..a71d80f 100644
--- a/SystemUI/src/com/android/systemui/BatteryMeterView.java
+++ b/SystemUI/src/com/android/systemui/BatteryMeterView.java
@@ -5,6 +5,7 @@ import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.pm.PackageManager;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
 import android.graphics.Bitmap;
@@ -528,6 +529,7 @@ public class BatteryMeterView extends View implements DemoMode, BatteryStateChan
 
             drawBattery(c, tracker);
             if (mAnimationsEnabled) {
+                // TODO: Allow custom animations to be used
             }
         }
 
diff --git a/SystemUI/src/com/android/systemui/SmartGestureService.java b/SystemUI/src/com/android/systemui/SmartGestureService.java
index e63aacf..b09f8cc 100644
--- a/SystemUI/src/com/android/systemui/SmartGestureService.java
+++ b/SystemUI/src/com/android/systemui/SmartGestureService.java
@@ -97,7 +97,19 @@ public class SmartGestureService extends Service {
     private boolean mCall = false;
     private boolean mCanAnswerCall = false;
     private boolean isCallStateChanged = false;
-
+	private boolean isBringUp = false;
+    private static int gSensorChangedCount = 0;
+    private static double[][] g_Value = { {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0},
+                                            {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0},
+                                            {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0} };
+    private static long[] gSensorTimestamp = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    private static boolean oneAction = false;
+    private static boolean twoAction = false;
+    private static boolean threeAction = false;
+    private static double oneActionTimesStep = 0;
+    private static double twoActionTimesStep = 0;
+    private static double threeActionTimesStep = 0;
+    
     @Override
     public void onCreate() {
         super.onCreate();
@@ -133,6 +145,10 @@ public class SmartGestureService extends Service {
                 if (bundle == null) {
                     return;
                 }
+                if(gSensorChangedCount >= 15)
+                {
+                    gSensorChangedCount = 0;
+                }
                 String state = bundle.getString(TelephonyManager.EXTRA_STATE);
                 if (state.equals(TelephonyManager.EXTRA_STATE_RINGING)) {
                     isCallRinging = true;
@@ -152,6 +168,7 @@ public class SmartGestureService extends Service {
                     } else {
                         mCanSmartAnswerCall = false;
                     }
+                    
                 } else {
                     isCallRinging = false;
                 }
@@ -160,9 +177,9 @@ public class SmartGestureService extends Service {
                     isCallStateChanged = false;
                     mCanSmartAnswerCall = false;
                     mCanSilentCall = false;
-                }
+                }                
                 updateGravitySensor();
-                updateProximitySensor();
+                updateProximitySensor();          
             }
             else if (action.equals(ACTION_ALARM_ALERT)) {
                 isFirstDegreeValue = false;
@@ -245,6 +262,8 @@ public class SmartGestureService extends Service {
                     updateGravitySensor();
                 }
             }
+
+            
         }
     };
 
@@ -259,7 +278,7 @@ public class SmartGestureService extends Service {
             Log.d(TAG, "Start PSensor");
             mSensorMgr.registerListener(mSensorEventListener,
                     mProximitySensor,
-                    SensorManager.SENSOR_DELAY_NORMAL);
+                    SensorManager.SENSOR_DELAY_UI);
             mProximitySensorStarted = true;
         }
         boolean stopSensor = mProximitySensorStarted
@@ -287,6 +306,15 @@ public class SmartGestureService extends Service {
                 && (mCanSilentCall || mCanSmartDialed || isAlarmAlert || mCanSmartAnswerCall);
         if (start) {
             Log.d(TAG, "Start Gravity Sensor");
+            
+            gSensorChangedCount = 0;
+            isBringUp = false;
+            threeActionTimesStep = 0;
+            twoActionTimesStep = 0;
+            oneActionTimesStep = 0;
+            oneAction = false;
+            twoAction = false;
+            threeAction = false;
             mSensorMgr.registerListener(mSensorEventListener,
                     mGravitySensor,
                     SensorManager.SENSOR_DELAY_NORMAL);
@@ -308,6 +336,7 @@ public class SmartGestureService extends Service {
         }
     }
 
+
     private final SensorEventListener mSensorEventListener = new SensorEventListener() {
         @Override
         public void onAccuracyChanged(Sensor sensor, int accuracy) {
@@ -342,27 +371,49 @@ public class SmartGestureService extends Service {
                 }
             }
             
-            if(mPSensorNear && mGSensorChanged && !isAlarmAlert && mCanCallNow)
+            if(mPSensorNear &&  !isAlarmAlert && mCanCallNow && !mCanSmartAnswerCall && isBringUp &&mGSensorChanged)
             {
-                dial();
                 mCanCallNow = false;
-                /*    if(mCanCallNow && mCanSmartDialed)
-                    {
-                        dial();
-                        mCanCallNow = false;
-                    }else if(mCanSmartAnswerCall){
-                        sendBroadcastToAcceptCall();
-                        mCanSmartAnswerCall = false;
-                    }  */ 
+                mPSensorNear = false;
+                isBringUp = false;
+                threeActionTimesStep = 0;
+                twoActionTimesStep = 0;
+                oneActionTimesStep = 0;
+                oneAction = false;
+                twoAction = false;
+                threeAction = false;
+                for(int k = 0; k <= 14; k++ ){
+                    g_Value[k][0] = 0.0;
+                    g_Value[k][1] = 0.0;
+                    g_Value[k][2] = 0.0;
+                } 
+                gSensorChangedCount = 0;
+                dial();
             }
-            else if(mPSensorNear && mGSensorChanged && !isAlarmAlert && mCanSmartAnswerCall)
+            else if(mPSensorNear && !isAlarmAlert && mCanSmartAnswerCall && isBringUp && mGSensorChanged)
             {
-                sendBroadcastToAcceptCall();
                 mCanSmartAnswerCall = false;
+                mPSensorNear = false;
+                isBringUp = false;
+                threeActionTimesStep = 0;
+                twoActionTimesStep = 0;
+                oneActionTimesStep = 0;
+                oneAction = false;
+                twoAction = false;
+                threeAction = false;
+                for(int l = 0; l <= 14; l++ )
+                {
+                    g_Value[l][0] = 0.0;
+                    g_Value[l][1] = 0.0;
+                    g_Value[l][2] = 0.0;
+                } 
+                gSensorChangedCount = 0;
+                sendBroadcastToAcceptCall();
             }
             
         }
     };
+ 
 
     private void movePhoto() {
         Log.d(TAG, "Switch to next photo");
@@ -393,7 +444,7 @@ public class SmartGestureService extends Service {
     }
 
     private void gravitySensorChanged(SensorEvent event) {
-        double x = event.values[SensorManager.DATA_X];
+	    double x = event.values[SensorManager.DATA_X];
         double y = event.values[SensorManager.DATA_Y];
         double z = event.values[SensorManager.DATA_Z];
 
@@ -432,6 +483,46 @@ public class SmartGestureService extends Service {
         }else{
             mGSensorChanged = false;
         }
+		
+        if(gSensorChangedCount == 15){
+            long timesstap = gSensorTimestamp[14] - gSensorTimestamp[0];
+        }
+            
+        if((gSensorChangedCount == 15) && ((gSensorTimestamp[14] - gSensorTimestamp[0] >= 550000000) && (gSensorTimestamp[14] - gSensorTimestamp[0] <= 1000000000))){
+            for(int ll = 0; ll <= 14; ll++){
+                if(g_Value[ll][1] > 7.0)
+                {
+                    threeActionTimesStep = gSensorTimestamp[ll];
+                    threeAction = true;
+                }else if( (g_Value[ll][1] > 3.0 && g_Value[ll][1] < 7.0) && (g_Value[ll][2] > 3.0 && g_Value[ll][2] < 9.0) )
+                {
+                    twoActionTimesStep = gSensorTimestamp[ll];
+                    twoAction = true;
+                }else if( ((g_Value[ll][0] < -4.0 && g_Value[ll][0] > -8.0) || (g_Value[ll][0] > 3.5 && g_Value[ll][0] < 8.0)) && (g_Value[ll][1] > 3.0 && g_Value[ll][1] < 7.0))
+                {
+                    oneActionTimesStep = gSensorTimestamp[ll];
+                    oneAction = true;
+                }
+            }
+
+            if(threeAction && (twoAction || oneAction) && (threeActionTimesStep > oneActionTimesStep) && (threeActionTimesStep > oneActionTimesStep))
+            {
+                isBringUp = true;
+            }else{
+                isBringUp = false;
+            }
+            gSensorChangedCount = 0;
+        }else if((gSensorChangedCount >= 0) && (gSensorChangedCount <= 14)){ 
+            g_Value[gSensorChangedCount][0] = event.values[SensorManager.DATA_X];
+            g_Value[gSensorChangedCount][1] = event.values[SensorManager.DATA_Y];
+            g_Value[gSensorChangedCount][2] = event.values[SensorManager.DATA_Z];
+            gSensorTimestamp[gSensorChangedCount] = event.timestamp;
+            gSensorChangedCount++;
+        }else if(gSensorChangedCount == 15)
+        {
+            gSensorChangedCount = 0;
+        }
+        
     }
         
     private void dial() {
diff --git a/SystemUI/src/com/android/systemui/applock/ConfirmAppLockPasswordActivity.java b/SystemUI/src/com/android/systemui/applock/ConfirmAppLockPasswordActivity.java
index 60c5a39..2771d6a 100644
--- a/SystemUI/src/com/android/systemui/applock/ConfirmAppLockPasswordActivity.java
+++ b/SystemUI/src/com/android/systemui/applock/ConfirmAppLockPasswordActivity.java
@@ -163,7 +163,11 @@ public class ConfirmAppLockPasswordActivity extends Activity implements OnClickL
         }*/
 	
 	updateMonitor = KeyguardUpdateMonitor.getInstance(this);
-	mFpm = (FingerprintManager) getSystemService(Context.FINGERPRINT_SERVICE);
+	mFpm = updateMonitor.getFpInstance();
+	if(mFpm == null){
+	     mFpm = (FingerprintManager) getSystemService(Context.FINGERPRINT_SERVICE);
+	     updateMonitor.setFpInstance(mFpm);
+	}
 	
         if(updateMonitor.isUnlockWithFingerprintPossible(ActivityManager.getCurrentUser()) && isUnlockAppEnable() && (!mFpm.isFpUnlockAppLock())){
             headerString = getResources().getString(R.string.confirm_password_header_title2);
@@ -288,16 +292,18 @@ public class ConfirmAppLockPasswordActivity extends Activity implements OnClickL
 	if(deadline >0){
 	    countDownTimes(deadline);	
 	}else{
-        if (updateMonitor.isUnlockWithFingerprintPossible(userId) && isUnlockAppEnable() && (!mFpm.isFpUnlockAppLock())) {
+        if (updateMonitor.isUnlockWithFingerprintPossible(userId) && isUnlockAppEnable() && (!mFpm.isFpUnlockAppLock()) && updateMonitor.getKeyguardStatus()) {
 	    if(!updateMonitor.isFingerUp){
 		mgfObserver.startObserving(DEV_PATH);
 		isObserving = true;
 		return;
 	    }
+	    mFingerprintCancelSignal = updateMonitor.getCancelSignalInstance();
             if (mFingerprintCancelSignal != null) {
                 mFingerprintCancelSignal.cancel();
             }
             mFingerprintCancelSignal = new CancellationSignal();
+	    updateMonitor.setCancelSignalInstance(mFingerprintCancelSignal);
             mFpm.authenticate(null, mFingerprintCancelSignal, 0, mAuthenticationCallback, null, userId);
 	    updateMonitor.setFingerprintRunningState(updateMonitor.FINGERPRINT_STATE_RUNNING);
 	    AuthenticationRunning = true;
@@ -322,15 +328,17 @@ public class ConfirmAppLockPasswordActivity extends Activity implements OnClickL
         //if (updateMonitor.mFingerprintRunningState == updateMonitor.FINGERPRINT_STATE_RUNNING && mFingerprintCancelSignal != null) {
         if (AuthenticationRunning && mFingerprintCancelSignal != null) {
             if(DEBUG) Log.d("cdfinger","onPause, mFingerprintCancelSignal.cancel");
-	    updateMonitor.applock_cancle_verify=true;
+	    updateMonitor.applock_cancle_verify=false;
             mFingerprintCancelSignal.cancel();
             mFingerprintCancelSignal = null;
+	    updateMonitor.setCancelSignalInstance(mFingerprintCancelSignal);
 	    AuthenticationRunning = false;
 	    updateMonitor.setFingerprintRunningState(updateMonitor.FINGERPRINT_STATE_CANCELLING);
 	    updateMonitor.applock_verify=false;
-	    mFpm.setFpUnlockApp(false);
+	    //mFpm.setFpUnlockApp(false);
+	    updateMonitor.updateFingerprintListener();
         }
-	if(!SystemProperties.getBoolean(PERSIST_NAVIGATION_BAR, false)){
+	if(!SystemProperties.getBoolean(PERSIST_NAVIGATION_BAR, false) && updateMonitor.getKeyguardStatus()){
 	    writeFile(GF_MODE,"0");
 	}
 	mFailedAttempts = 0;
@@ -472,6 +480,7 @@ public class ConfirmAppLockPasswordActivity extends Activity implements OnClickL
 		if (updateMonitor.mFingerprintRunningState == updateMonitor.FINGERPRINT_STATE_RUNNING && mFingerprintCancelSignal != null) {
             		mFingerprintCancelSignal.cancel();
             		mFingerprintCancelSignal = null;
+			updateMonitor.setCancelSignalInstance(mFingerprintCancelSignal);
             		updateMonitor.setFingerprintRunningState(updateMonitor.FINGERPRINT_STATE_CANCELLING);
         	}
             }
@@ -480,10 +489,12 @@ public class ConfirmAppLockPasswordActivity extends Activity implements OnClickL
             public void onFinish() {
         	header.setText(headerString);
 	        if (updateMonitor.isUnlockWithFingerprintPossible(UserHandle.myUserId()) && isUnlockAppEnable() && (!mFpm.isFpUnlockAppLock())) {
+		    mFingerprintCancelSignal = updateMonitor.getCancelSignalInstance();
         	    if (mFingerprintCancelSignal != null) {
                 	mFingerprintCancelSignal.cancel();
             	    }
             	    mFingerprintCancelSignal = new CancellationSignal();
+		    updateMonitor.setCancelSignalInstance(mFingerprintCancelSignal);
             	    mFpm.authenticate(null, mFingerprintCancelSignal, 0, mAuthenticationCallback, null, UserHandle.myUserId());
             	    updateMonitor.setFingerprintRunningState(updateMonitor.FINGERPRINT_STATE_RUNNING);
 		    AuthenticationRunning = true;
@@ -555,6 +566,7 @@ public class ConfirmAppLockPasswordActivity extends Activity implements OnClickL
                 case MSG_FP_ONSUCCESS:
                     DeletePackageName();
                     StartProtectedActivity();
+		    mFpm.setFpUnlockApp(false); 
                     finish();
                     break;
                 case MSG_FP_ONFAIL:
@@ -569,6 +581,7 @@ public class ConfirmAppLockPasswordActivity extends Activity implements OnClickL
 
                             mFingerprintCancelSignal.cancel();
                             mFingerprintCancelSignal = null;
+			    updateMonitor.setCancelSignalInstance(mFingerprintCancelSignal);
                             updateMonitor.setFingerprintRunningState(updateMonitor.FINGERPRINT_STATE_CANCELLING);
 			    mFpm.setFpUnlockAppLock(true);
                 	}
@@ -580,125 +593,6 @@ public class ConfirmAppLockPasswordActivity extends Activity implements OnClickL
         };
     };
 
-/*
-    private IFc909ResultListener mIFc909Result = new IFc909ResultListener.Stub() {
-        @Override
-        public void success() throws RemoteException {
-            if(DEBUG) Log.i(TAG, "qucii fp verfy success");
-	    mQcFingerprintManager.SetCancelFlag();
-	    mQcFingerprintManager.ReleaseExcuteLock();
-            Message msg = new Message();
-            msg.what = MSG_FP_ONSUCCESS;
-            mFingerprintVerifyHandler.sendMessage(msg);
-        }
-
-        @Override
-        public void fail() throws RemoteException {
-            if(DEBUG) Log.i(TAG, "qucii fp verfy fail");
-	    mQcFingerprintManager.SetCancelFlag();
-	    mQcFingerprintManager.ReleaseExcuteLock();
-                Message msg = new Message();
-                msg.what = MSG_FP_ONFAIL;
-                mFingerprintVerifyHandler.sendMessage(msg);
-                return;
-        }
-        @Override
-        public void cancel() throws RemoteException {
-            if(DEBUG) Log.i(TAG, "qucii fp cancel");
-	    mQcFingerprintManager.SetCancelFlag();
-	    mQcFingerprintManager.ReleaseExcuteLock();
-            Message msg = new Message();
-            msg.what = MSG_FP_CANCEL;
-            mFingerprintVerifyHandler.sendMessage(msg);
-        }
-    };
-
-
-
-    private final Runnable mCheckFingerDetectRunnable = new Runnable() {
-        @Override
-        public void run() {
-            synchronized(this){
-                while(true){
-                    if(mQcFingerprintManager.isFingerDetect() && mQcFingerprintManager.isKeyguardDone()){
-                        if(DEBUG) Log.i(TAG,"fingerprint verify........");
-                        FingerprintVerify();
-                        return;
-                    }else{
-                        if(DEBUG) Log.i(TAG,"fingerprint not detect...");
-                    }
-    
-                    try {
-                        Thread.currentThread().sleep(100);
-                    } catch (InterruptedException e) {
-                        e.printStackTrace();
-                    }
-                    
-                    if(!mQcFingerprintManager.isFingerDetect() && !mQcFingerprintManager.isKeyguardDone() && !activityStatus){
-                        if(DEBUG) Log.i(TAG,"fingerprint not detect,and not detect,return...");
-                        return;
-                    }
-                }
-            }
-        }
-    };
-
-    private void FingerprintVerify(){
-        if(mIFc909Result != null){
-            if(DEBUG) Log.i(TAG,"SetDevicelistener...");
-            mQcFingerprintManager.SetResultlistener(mIFc909Result);
-        }
-
-        if(mQcFingerprintManager != null){
-            if(mQcFingerprintManager.GetOprStatus()){
-                if(DEBUG) Log.d(TAG, "CancelAction... ");
-                mQcFingerprintManager.CancelAction();
-            }
-            if(DEBUG) Log.d(TAG, "verify... ");
-            mQcFingerprintManager.Verify();
-        }
-    }
-
-    private final Runnable mFingerprintTouchDetectRunnable = new Runnable() {
-        @Override
-        public void run() {
-            synchronized(this){
-                while(true){
-                    if(mQcFingerprintManager != null){
-                        if(mQcFingerprintManager.TouchDetect()){
-                            if(DEBUG) Log.d(TAG, "touch detect and mQcFingerprintManager.Verify ...");
-                            mFingerprintVerifyHandler.removeCallbacks(mFpVfRunnable);
-                            mFingerprintVerifyHandler.postDelayed(mFpVfRunnable, 250);
-                            return;
-                        }else{
-                            if(DEBUG) Log.d(TAG, "keyguardDone finger not detected...");
-                            if(mQcFingerprintManager.GetOprStatus()){
-                                if(DEBUG) Log.d(TAG, "CancelAction... ");
-                                mQcFingerprintManager.CancelAction();
-                            }
-                        }
-                        if(!mQcFingerprintManager.isKeyguardDone()){
-                            return;
-                        }
-
-                    }else{
-                        return;
-                    }
-                } 
-            }
-        }
-    };
-    private final Runnable mFpVfRunnable = new Runnable(){
-        @Override
-        public void run() {
-            if(mQcFingerprintManager.GetOprStatus()){
-                if(DEBUG) Log.d(TAG, "mFpVfRunnable CancelAction... ");
-                mQcFingerprintManager.CancelAction();
-            }
-            mQcFingerprintManager.Verify();
-        }
-    };
-*/
     private void startLauncher(){
         Intent mIntent = new Intent();
         mIntent.addCategory("android.intent.category.HOME");
@@ -801,7 +695,9 @@ public class ConfirmAppLockPasswordActivity extends Activity implements OnClickL
 	    updateMonitor.applock_cancle_verify=false;
 	    updateMonitor.applock_verify=false;
 	    AuthenticationRunning = false;
-	    if(!SystemProperties.getBoolean(PERSIST_NAVIGATION_BAR, false)){
+	    mFpm.setFpUnlockApp(false);
+	    updateMonitor.updateFingerprintListener();
+	    if(!SystemProperties.getBoolean(PERSIST_NAVIGATION_BAR, false) && updateMonitor.getKeyguardStatus()){
 	    	writeFile(GF_MODE,"0");
 	    }
         }
@@ -830,15 +726,18 @@ public class ConfirmAppLockPasswordActivity extends Activity implements OnClickL
         public void onUEvent(UEvent event) {
 	    String status = event.get("STATUS");
 	    if(status.equals("up")){ 
-                if (updateMonitor.isUnlockWithFingerprintPossible(ActivityManager.getCurrentUser()) && isUnlockAppEnable()) {
+                if (updateMonitor.isUnlockWithFingerprintPossible(ActivityManager.getCurrentUser()) && isUnlockAppEnable() && updateMonitor.getKeyguardStatus()) {
+		    mFingerprintCancelSignal = updateMonitor.getCancelSignalInstance();
             	    if (mFingerprintCancelSignal != null) {
                     	mFingerprintCancelSignal.cancel();
             	    }
             	    mFingerprintCancelSignal = new CancellationSignal();
+		    updateMonitor.setCancelSignalInstance(mFingerprintCancelSignal);
             	    mFpm.authenticate(null, mFingerprintCancelSignal, 0, mAuthenticationCallback, null, ActivityManager.getCurrentUser());
             	    updateMonitor.setFingerprintRunningState(updateMonitor.FINGERPRINT_STATE_RUNNING);
             	    AuthenticationRunning = true;
             	    updateMonitor.applock_verify=true;
+	    	    mFpm.setFpUnlockApp(true);
             	    if(!SystemProperties.getBoolean(PERSIST_NAVIGATION_BAR, false)){
                     	writeFile(GF_MODE,"1");
             	    }
diff --git a/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java b/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
index 70addbe..f1f1178 100644
--- a/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
+++ b/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
@@ -658,9 +658,11 @@ public class KeyguardViewMediator extends SystemUI {
             mUpdateMonitor.registerCallback(mUpdateCallback);
             
     	    //4 lines add by wumin
+	    /*
     	    if(!isNavigationEnable()){
                 	writeFile(GF_MODE,"0");
     	    }
+	    */
     	    Settings.System.putString(mContext.getContentResolver(), SETTINGS_NEEDLOCK_APP_PACKAGENAMES,null);
             String appString = Settings.System.getString(mContext.getContentResolver(), SETTINGS_NEEDLOCK_APP_GLOBAL_PACKAGENAMES);
             Settings.System.putString(mContext.getContentResolver(), SETTINGS_NEEDLOCK_APP_PACKAGENAMES,appString);
@@ -1280,6 +1282,8 @@ public class KeyguardViewMediator extends SystemUI {
         EventLog.writeEvent(70000, 2);
         Message msg = mHandler.obtainMessage(KEYGUARD_DONE, authenticated ? 1 : 0);
         mHandler.sendMessage(msg);
+	//add by wumin
+	mUpdateMonitor.keyguardDone();
     }
 
     /**
diff --git a/SystemUI/src/com/android/systemui/screenshot/GlobalScreenshot.java b/SystemUI/src/com/android/systemui/screenshot/GlobalScreenshot.java
index 9da4c80..50ce841 100644
--- a/SystemUI/src/com/android/systemui/screenshot/GlobalScreenshot.java
+++ b/SystemUI/src/com/android/systemui/screenshot/GlobalScreenshot.java
@@ -67,6 +67,7 @@ import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import android.widget.Toast;
+import android.media.AudioManager;
 /**
  * POD used in the AsyncTask which saves an image in the background.
  */
@@ -413,6 +414,7 @@ public class GlobalScreenshot {
 
     private Context mContext;
     private TelephonyManager tm;
+    private AudioManager  rm;
     private WindowManager mWindowManager;
     private WindowManager.LayoutParams mWindowLayoutParams;
     private NotificationManager mNotificationManager;
@@ -443,6 +445,7 @@ public class GlobalScreenshot {
     public GlobalScreenshot(Context context) {
         Resources r = context.getResources();
         tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+        rm = (AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
         mContext = context;
         LayoutInflater layoutInflater = (LayoutInflater)
                 context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
@@ -705,7 +708,7 @@ public class GlobalScreenshot {
             @Override
             public void run() {
                 // Play the shutter sound to notify that we've taken a screenshot
-                if (tm.getCallState() == TelephonyManager.CALL_STATE_IDLE) {
+                if (tm.getCallState() == TelephonyManager.CALL_STATE_IDLE&&rm.getRingerMode()== AudioManager.RINGER_MODE_NORMAL) {
                     mCameraSound.play(MediaActionSound.SHUTTER_CLICK);
                 }
                 mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
diff --git a/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java b/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
index bd55173..40cba7d 100644
--- a/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
+++ b/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
@@ -194,7 +194,7 @@ public class KeyguardIndicationController {
         } catch (RemoteException e) {
             Log.e(TAG, "Error calling IBatteryStats: ", e);
         }
-        final boolean hasChargingTime = /*chargingTimeRemaining > 0*/ false;// 去掉显示"还有xx时间充满" by yangfan 
+        final boolean hasChargingTime = /*chargingTimeRemaining > 0*/ false;// add by yangfan 
 
         int chargingId;
         switch (mChargingSpeed) {
@@ -215,7 +215,7 @@ public class KeyguardIndicationController {
                 break;
         }
 
-        // 只显示'正在充电' by yangfan 
+        // add  by yangfan 
         chargingId = R.string.keyguard_plugged_in;
         if (hasChargingTime) {
         	String chargingTimeFormatted = Formatter.formatShortElapsedTimeRoundingUpToMinutes(
diff --git a/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java b/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
index a0620cc..3c6b347 100644
--- a/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
+++ b/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
@@ -228,6 +228,7 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
     private boolean isSettings = false;
     private boolean isFpTouchMode;
     private boolean isBroadcastAction = false;
+    private LockIcon mLockIcon = null;
     //add end
     // additional instrumentation for testing purposes; intended to be left on during development
     public static final boolean CHATTY = DEBUG;
@@ -913,6 +914,8 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
                 (KeyguardBottomAreaView) mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
         mKeyguardBottomArea.setActivityStarter(this);
         mKeyguardBottomArea.setAssistManager(mAssistManager);
+	//add by wumin
+	mLockIcon = mKeyguardBottomArea.getLockIcon();
         mKeyguardIndicationController = new KeyguardIndicationController(mContext,
                 (KeyguardIndicationTextView) mStatusBarWindow.findViewById(
                         R.id.keyguard_indication_text),
@@ -1215,6 +1218,11 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
         mStatusBarKeyguardViewManager = keyguardViewMediator.registerStatusBar(this,
                 mStatusBarWindow, mStatusBarWindowManager, mScrimController,
                 mFingerprintUnlockController);
+	//add by wumin
+	if(mLockIcon != null){ 
+	    mStatusBarKeyguardViewManager.setLockIcon(mLockIcon);
+	}
+	//add end
         mKeyguardIndicationController.setStatusBarKeyguardViewManager(
                 mStatusBarKeyguardViewManager);
         mFingerprintUnlockController.setStatusBarKeyguardViewManager(mStatusBarKeyguardViewManager);
@@ -1387,7 +1395,6 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
             return;
         }
         boolean isHeadsUped = mUseHeadsUp && shouldInterrupt(shadeEntry);
-        Log.d(TAG, "isHeadsUped : " + isHeadsUped);
         if (isHeadsUped) {
         	mNotificationPanel.showPage(0);// show Notification by yangfan 
             mHeadsUpManager.showNotification(shadeEntry);
@@ -2476,7 +2483,7 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
 		mNotificationPanel.setBackground(mBitmapDrawable);
 	}
 
-	@Override
+    @Override
     public void animateExpandSettingsPanel() {
         if (SPEW) Log.d(TAG, "animateExpand: mExpandedVisible=" + mExpandedVisible);
         if (!panelsEnabled()) {
@@ -4751,6 +4758,7 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
                     intent.setComponent(cn);
                      intent.setFlags(Intent.FLAG_ACTIVITY_NO_USER_ACTION | Intent.FLAG_ACTIVITY_NEW_TASK);
                     mContext.startActivity(intent);
+                hideCallBar();
 
 
             }
diff --git a/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java b/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
index 9f68c9a..5765e49 100644
--- a/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
+++ b/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
@@ -29,10 +29,13 @@ import android.view.WindowManagerGlobal;
 
 import com.android.internal.widget.LockPatternUtils;
 import com.android.keyguard.KeyguardUpdateMonitor;
+//add by wumin
+import com.android.keyguard.KeyguardUpdateMonitor.FingerprintVerifyCallback;
 import com.android.keyguard.ViewMediatorCallback;
 import com.android.systemui.statusbar.CommandQueue;
 
 import static com.android.keyguard.KeyguardHostView.OnDismissAction;
+import android.util.Log;
 
 /**
  * Manages creating, showing, hiding and resetting the keyguard within the status bar. Calls back
@@ -80,6 +83,8 @@ public class StatusBarKeyguardViewManager {
     private boolean mDeferScrimFadeOut;
     //add by wumin
     private KeyguardUpdateMonitor mKeyguardUpdateMonitor;
+    private LockIcon mLockIcon = null;
+
     public StatusBarKeyguardViewManager(Context context, ViewMediatorCallback callback,
             LockPatternUtils lockPatternUtils) {
         mContext = context;
@@ -87,6 +92,7 @@ public class StatusBarKeyguardViewManager {
         mLockPatternUtils = lockPatternUtils;
     	//add by wumin
     	mKeyguardUpdateMonitor = KeyguardUpdateMonitor.getInstance(mContext);
+	mKeyguardUpdateMonitor.setFreshLockIconListener(mFingerprintVerifyCallback);
     }
 
     public void registerStatusBar(PhoneStatusBar phoneStatusBar,
@@ -108,6 +114,9 @@ public class StatusBarKeyguardViewManager {
      */
     public void show(Bundle options) {
         mShowing = true;
+	//add by wumin
+	mKeyguardUpdateMonitor.keyguardShow();
+
         mStatusBarWindowManager.setKeyguardShowing(true);
         mScrimController.abortKeyguardFadingOut();
         reset();
@@ -270,6 +279,8 @@ public class StatusBarKeyguardViewManager {
      */
     public void hide(long startTime, final long fadeoutDuration) {
         mShowing = false;
+	//add by wumin
+	mKeyguardUpdateMonitor.keyguardHide();
 
         long uptimeMillis = SystemClock.uptimeMillis();
         long delay = Math.max(0, startTime + HIDE_TIMING_CORRECTION_MS - uptimeMillis);
@@ -539,7 +550,12 @@ public class StatusBarKeyguardViewManager {
 	public void keyguardDone() {
 		mViewMediatorCallback.keyguardDone(false);
 	}
-    
+
+    public void setLockIcon(LockIcon lockIcon){
+	mLockIcon = lockIcon;
+    }
+    //add end
+ 
     public void animateCollapsePanels(float speedUpFactor) {
         mPhoneStatusBar.animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_NONE, true /* force */,
                 false /* delayed */, speedUpFactor);
@@ -566,4 +582,15 @@ public class StatusBarKeyguardViewManager {
     public ViewRootImpl getViewRootImpl() {
         return mPhoneStatusBar.getStatusBarView().getViewRootImpl();
     }
+
+    //add by wumin
+    private KeyguardUpdateMonitor.FingerprintVerifyCallback mFingerprintVerifyCallback = new FingerprintVerifyCallback(){
+
+	@Override
+	public void freshLockIcon(){
+	    if(mLockIcon != null){
+	        mLockIcon.update();	
+	    }
+	}
+    };
 }
diff --git a/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java b/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java
index 64f2a95..f14fb4e 100644
--- a/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java
+++ b/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java
@@ -975,11 +975,7 @@ public class MobileSignalController extends SignalController<
                         + " dataState=" + state.getDataRegState());
             }
             mServiceState = state;
-            boolean isCdma = TelephonyManager.PHONE_TYPE_CDMA == TelephonyManager.getDefault()
-                    .getCurrentPhoneType(mSubscriptionInfo.getSubscriptionId());
-            if (!isCdma) {
-            	updateNetworkName(mLastShowSpn, mLastSpn, mLastDataSpn, mLastShowPlmn, mLastPlmn);
-			}
+            updateNetworkName(mLastShowSpn, mLastSpn, mLastDataSpn, mLastShowPlmn, mLastPlmn);
             updateTelephony();
         }
 
diff --git a/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java b/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java
index f6bd576..ebeed59 100644
--- a/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java
+++ b/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java
@@ -507,6 +507,27 @@ public class NetworkControllerImpl extends BroadcastReceiver
                         mHasMobileDataFeature, mPhone, mCallbackHandler,
                         this, subscriptions.get(i), mSubDefaults, mReceiverHandler.getLooper());
                 mMobileSignalControllers.put(subId, controller);
+
+                String iccId = subscriptions.get(i).getIccId();
+                Log.d(TAG, "machao---BROCAST_SPN_FORCE---IccId:"+iccId);
+
+                if(iccId != null) {
+                    Log.d(TAG, "machao---BROCAST_SPN_FORCE---$$$$");
+                    String iccIdFirst = iccId.substring(0, 4); 
+                    String iccIdSec = iccId.substring(4, 6); 
+                    if (iccIdFirst.contains("8986") && ((iccIdSec.contains("03")) || (iccIdSec.contains("05")) || (iccIdSec.contains("11")))) {
+                        Log.d(TAG, "machao---BROCAST_SPN_FORCE_CDMA---set 1 !!");
+                        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.BROCAST_SPN_FORCE_CDMA, 1); 
+                    } else if (iccIdFirst.contains("8986")) {
+                        Log.d(TAG, "machao---BROCAST_SPN_FORCE_GSM---set 1 !!");
+                        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.BROCAST_SPN_FORCE_GSM, 1); 
+                    } else {
+                        Log.e(TAG, "@@@ERROR: iccId invalid !");
+                    }
+                } else {
+                    Log.e(TAG, "@@@ERROR: iccId is NULL !!!");
+                }
+
                 if (subscriptions.get(i).getSimSlotIndex() == 0) {
                     mDefaultSignalController = controller;
                 }
diff --git a/SystemUI/src/com/android/systemui/volume/VolumeDialog.java b/SystemUI/src/com/android/systemui/volume/VolumeDialog.java
index 502379b..e8cc021 100644
--- a/SystemUI/src/com/android/systemui/volume/VolumeDialog.java
+++ b/SystemUI/src/com/android/systemui/volume/VolumeDialog.java
@@ -42,6 +42,7 @@ import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
 import android.os.SystemClock;
+import android.provider.Settings;
 import android.provider.Settings.Global;
 import android.util.DisplayMetrics;
 import android.util.Log;
@@ -1027,6 +1028,11 @@ public class VolumeDialog {
                     mRow.requestedLevel = userLevel;
                     Events.writeEvent(mContext, Events.EVENT_TOUCH_LEVEL_CHANGED, mRow.stream,
                             userLevel);
+                    if(mRow.stream == AudioManager.STREAM_RING){// save the volume_ring by headset_on
+                        boolean headset_on = mAudioManager.isWiredHeadsetOn();
+                        Settings.Secure.putInt(mContext.getContentResolver(),
+                            headset_on ? Settings.Global.RINGTONE_VOLUME_HEADSET_ON : Settings.Global.RINGTONE_VOLUME_HEADSET_OFF, userLevel);
+                    }
                 }
             }
         }
diff --git a/SystemUI/src/com/android/systemui/volume/VolumeDialogController.java b/SystemUI/src/com/android/systemui/volume/VolumeDialogController.java
index 32d6805..08b1c83 100644
--- a/SystemUI/src/com/android/systemui/volume/VolumeDialogController.java
+++ b/SystemUI/src/com/android/systemui/volume/VolumeDialogController.java
@@ -311,6 +311,11 @@ public class VolumeDialogController {
         if (changed && fromKey) {
             Events.writeEvent(mContext, Events.EVENT_KEY, stream, lastAudibleStreamVolume);
         }
+        if(fromKey && stream == AudioManager.STREAM_RING){// save the volume_ring by headset_on
+            boolean headset_on = mAudio.isWiredHeadsetOn();
+            Settings.Secure.putInt(mContext.getContentResolver(),
+                headset_on ? Settings.Global.RINGTONE_VOLUME_HEADSET_ON : Settings.Global.RINGTONE_VOLUME_HEADSET_OFF, mAudio.getStreamVolume(stream));
+        }
     }
 
     private boolean updateActiveStreamW(int activeStream) {
-- 
2.8.3.windows.1

